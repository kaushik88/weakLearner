---
layout: post
title: "Traits"
tags:
- Scala
categories:
- Code
thumbnail_path: blog/personal/scala-logo.png
---

In this blog post, you'll learn about - 

1. Traits - Scala's version of interfaces.
2. Mixins - A design pattern using Traits.

### Traits

Traits are a lot similar to Java's *interface*. Consider the example below - 

trait Logger {
	def log(msg: String) // An abstract method
}

class ConsoleLogger extends Logger {
	def log(msg :String) = {
		println(msg)
	}
}

When you're overriding an abstract method of a trait, you do not need to use the @override method.

If you need to inherit more than 1 trait, you can add it using the *with* keyword:

	class ConsoleLogger extends *Logger* with **Cloneable** with **Serializeable**

Unlike Java interfaces, Scala traits can have concrete implementations.

trait ConsoleLogger {
	def log(msg :String) = {
		println(msg)
	}
}

class ProductionCode extends ProductionLibrary with ConsoleLogger {
	def execute() {
		log("Executing Production Code!!") // This is *mixed in*
	}
}

### Mixins

Consider the example below - 

trait Logged {
	def log(msg :String) {}
}

class ProductionCode extends ProductionLibrary with Logger {
	def execute() {
		log("Executing Production Code!!") 	// Nothing gets logged as there's no implementation of log.
	}
}

trait Slf4jLogger extends Logger {
	def log(msg :String) {
		org.slf4j.Log(msg)
	}
}

trait javaLogger extends Logger {
	def log(msg: String) {
		util.log(msg)
	}
}

So, now we can mix-in different Loggers at the time we create an object (this is an alternate way to have Dependency Injection in Scala).

val prodCode 	= new ProductionCode with Slf4jLogger   // In Production mode, use slf4j logger.
val debugCode   = new ProductionCode with ConsoleLogger // In debug mode -> Console Log.